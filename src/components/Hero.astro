---
import Button from './Button.astro';
import { Image } from 'astro:assets';
import floralHero from '../assets/floral_hero.png';
---

<section class="hero" data-hero>
	<div class="hero__bg" aria-hidden="true">
		<Image 
			src={floralHero} 
			alt=""
			width={1920}
			height={1080}
			format="webp"
			quality={85}
			loading="eager"
			fetchpriority="high"
			decoding="async"
		/>
	</div>
	<div class="hero__gradient" aria-hidden="true"></div>
	<canvas class="hero__particles" aria-hidden="true"></canvas>
	
	<div class="animated-lines" aria-hidden="true">
		<svg viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice">
			<!-- Flowing curved lines -->
			<path class="line line-1" d="M -200,300 Q 400,200 800,400 T 1600,350 2200,500" />
			<path class="line line-2" d="M -100,600 Q 500,500 900,700 T 1700,650 2100,800" />
			<path class="line line-3" d="M -300,150 Q 300,100 700,250 T 1500,200 2300,350" />
			<path class="line line-4" d="M 2200,200 Q 1800,300 1400,150 T 600,250 -200,100" />
			<path class="line line-5" d="M 2100,800 Q 1700,700 1300,850 T 500,750 -100,900" />
			<path class="line line-6" d="M 2300,500 Q 1900,600 1500,450 T 700,550 -300,400" />
		</svg>
	</div>
	
	<div class="container hero__container">
		<div class="hero__content">
			<h1 class="hero__title">
				Designer. Listener.<br />
				Process builder.
			</h1>
			<p class="hero__text">
				I'm Mindy. Product and visual designer with 10+ years in the design industry, 
				currently at Anheuser-Busch.
			</p>
			<Button href="#about">about me</Button>
		</div>
	</div>
</section>

<style>
	.hero {
		position: relative;
		display: flex;
		align-items: center;
		justify-content: center;
		overflow: hidden;
		padding-block: 6rem 4rem;
		min-height: 100vh;
	}

	.hero__bg {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 0;
		opacity: 0.4;
		mix-blend-mode: overlay;
		overflow: hidden;
	}

	.hero__bg::after {
		content: '';
		position: absolute;
		bottom: 0;
		left: 0;
		right: 0;
		height: 70%;
		background: linear-gradient(
			to top,
			var(--color-bg) 0%,
			rgba(6, 8, 6, 0.95) 20%,
			rgba(6, 8, 6, 0.7) 40%,
			rgba(6, 8, 6, 0.4) 60%,
			rgba(6, 8, 6, 0.15) 80%,
			transparent 100%
		);
		pointer-events: none;
		z-index: 1;
	}

	.hero__bg img {
		width: 100%;
		height: 100%;
		object-fit: cover;
		display: block;
		mask-image: linear-gradient(
			to bottom,
			black 0%,
			black 50%,
			rgba(0, 0, 0, 0.8) 70%,
			rgba(0, 0, 0, 0.4) 85%,
			transparent 100%
		);
		-webkit-mask-image: linear-gradient(
			to bottom,
			black 0%,
			black 50%,
			rgba(0, 0, 0, 0.8) 70%,
			rgba(0, 0, 0, 0.4) 85%,
			transparent 100%
		);
	}

 	.hero__gradient {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 0;
		background: linear-gradient(
			180deg,
			rgba(0, 0, 0, 0.6) 0%,
			rgba(0, 0, 0, 0.3) 30%,
			rgba(0, 0, 0, 0.1) 75%,
			transparent 100%
		);
		pointer-events: none;
	}

	.hero__particles {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 1;
		pointer-events: none;
		opacity: 0.5;
		will-change: contents;
	}

	.animated-lines {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 2;
		opacity: 0.35;
		pointer-events: none;
	}

	.animated-lines svg {
		width: 100%;
		height: 100%;
	}

	.line {
		fill: none;
		stroke: #6d521c;
		stroke-width: 1;
		stroke-linecap: round;
		will-change: transform;
	}

	/* Continuous draw-on/draw-off animation */
	@keyframes drawFlow1 {
		0% {
			stroke-dashoffset: 6000;
		}
		100% {
			stroke-dashoffset: -6000;
		}
	}

	@keyframes drawFlow2 {
		0% {
			stroke-dashoffset: -6000;
		}
		100% {
			stroke-dashoffset: 6000;
		}
	}

	@keyframes drawFlow3 {
		0% {
			stroke-dashoffset: 5500;
		}
		100% {
			stroke-dashoffset: -5500;
		}
	}

	.line-1 {
		stroke-dasharray: 2400 800;
		animation: drawFlow1 70s linear infinite;
	}

	.line-2 {
		stroke-dasharray: 2800 600;
		animation: drawFlow2 80s linear infinite;
		animation-delay: -15s;
	}

	.line-3 {
		stroke-dasharray: 2200 900;
		animation: drawFlow3 90s linear infinite;
		animation-delay: -30s;
	}

	.line-4 {
		stroke-dasharray: 2600 700;
		animation: drawFlow2 75s linear infinite;
		animation-delay: -10s;
	}

	.line-5 {
		stroke-dasharray: 2500 850;
		animation: drawFlow1 85s linear infinite;
		animation-delay: -25s;
	}

	.line-6 {
		stroke-dasharray: 2300 750;
		animation: drawFlow3 72s linear infinite;
		animation-delay: -35s;
	}

	.hero__container {
		position: relative;
		z-index: 3;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		text-align: center;
	}

	.hero__content {
		max-width: 690px;
		text-align: center;
		display: flex;
		flex-direction: column;
		align-items: center;
	}

	.hero__title {
		font-family: var(--font-display);
		font-size: 7rem;
		font-weight: 400;
		color: var(--color-accent);
		margin-bottom: 1.5rem;
		line-height: 1;
		text-transform: capitalize;
	}

	.hero__text {
		font-size: 1.125rem;
		line-height: 1.6;
		margin-bottom: 2rem;
		max-width: 640px;
	}

	/* Responsive */
	@media (max-width: 1024px) {
		.hero {
			padding-block: 6rem 3rem;
			min-height: 85vh;
		}
	}

	@media (max-width: 768px) {
		.hero {
			padding-block: 8rem 4rem;
			min-height: 85vh;
		}

		.hero__container {
			gap: 1.5rem;
		}

		.hero__title {
			font-size: 4rem;
			margin-bottom: 1rem;
			margin-top: 0;
		}

		.hero__text {
			font-size: 1rem;
			margin-bottom: 1.5rem;
		}

		.line {
			stroke-width: 0.75;
		}
	}

	/* Reduce motion for accessibility */
	@media (prefers-reduced-motion: reduce) {
		.line {
			animation: none;
			stroke-dashoffset: 0;
			stroke-dasharray: none;
		}
	}
</style>

<script>
	const hero = document.querySelector('[data-hero]') as HTMLElement | null;
	const lines = document.querySelectorAll('.line');
	const canvas = document.querySelector('.hero__particles') as HTMLCanvasElement | null;
	
	// Line parallax - throttled for performance
	if (lines.length && window.matchMedia('(hover: hover)').matches) {
		let ticking = false;
		const handleMouseMove = (e: MouseEvent) => {
			if (!ticking) {
				window.requestAnimationFrame(() => {
					const x = e.clientX / window.innerWidth;
					const y = e.clientY / window.innerHeight;
					
					lines.forEach((line, index) => {
						const speed = (index + 1) * 0.2;
						const offsetX = (x - 0.5) * 50 * speed;
						const offsetY = (y - 0.5) * 50 * speed;
						(line as HTMLElement).style.transform = `translate(${offsetX}px, ${offsetY}px)`;
					});
					
					ticking = false;
				});
				ticking = true;
			}
		};
		
		document.addEventListener('mousemove', handleMouseMove, { passive: true });
	}

	// Particle animation
	if (canvas && hero) {
		const ctx = canvas.getContext('2d');
		let particles: { x: number; y: number; vx: number; vy: number; size: number; life: number; decay: number; hue: number; alpha: number }[] = [];
		let mouseX = 0;
		let mouseY = 0;
		let animationId: number | null = null;

		const resize = () => {
			canvas.width = hero.clientWidth;
			canvas.height = hero.clientHeight;
		};

		const initParticles = () => {
			// Reduce particle count on mobile for better performance
			const isMobile = window.innerWidth < 768;
			const count = isMobile ? 50 : 100;
			particles = Array.from({ length: count }).map(() => ({
				x: Math.random() * canvas.width,
				y: Math.random() * canvas.height,
				vx: (Math.random() - 0.5) * 0.3,
				vy: (Math.random() - 0.5) * 0.3,
				size: Math.random() * 2 + 0.5,
				life: Math.random(),
				decay: Math.random() * 0.003 + 0.001,
				hue: 40 + Math.random() * 20,
				alpha: 0.2 + Math.random() * 0.3,
			}));
		};

		const animate = () => {
			if (!ctx) return;
			
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			particles.forEach((p) => {
				// Mouse interaction
				const dx = p.x - mouseX;
				const dy = p.y - mouseY;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < 120) {
					const force = (1 - dist / 120) * 0.3;
					const angle = Math.atan2(dy, dx);
					p.vx += Math.cos(angle) * force * -1;
					p.vy += Math.sin(angle) * force * -1;
				}

				// Gentle floating motion
				p.x += p.vx + Math.sin(Date.now() * 0.0008 + p.y * 0.01) * 0.1;
				p.y += p.vy + Math.cos(Date.now() * 0.0008 + p.x * 0.01) * 0.08;
				p.vx *= 0.99;
				p.vy *= 0.99;
				p.life -= p.decay;

				// Reset particle if dead or out of bounds
				if (p.life <= 0 || p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
					p.x = Math.random() * canvas.width;
					p.y = Math.random() * canvas.height;
					p.vx = (Math.random() - 0.5) * 0.2;
					p.vy = (Math.random() - 0.5) * 0.2;
					p.life = 1;
				}

				// Draw particle
				ctx.beginPath();
				ctx.fillStyle = `hsla(${p.hue}, 45%, 55%, ${p.alpha * p.life})`;
				ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
				ctx.fill();

				// Draw glow
				ctx.beginPath();
				ctx.fillStyle = `hsla(${p.hue}, 50%, 65%, ${p.alpha * 0.2 * p.life})`;
				ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
				ctx.fill();
			});

			animationId = requestAnimationFrame(animate);
		};

		resize();
		initParticles();
		animate();

		window.addEventListener('resize', () => {
			resize();
			initParticles();
		});

		if (window.matchMedia('(hover: hover)').matches) {
			hero.addEventListener('mousemove', (e) => {
				const rect = hero.getBoundingClientRect();
				mouseX = e.clientX - rect.left;
				mouseY = e.clientY - rect.top;
			}, { passive: true });

			hero.addEventListener('mouseleave', () => {
				mouseX = canvas.width / 2;
				mouseY = canvas.height / 2;
			});
		}
	}
</script>
